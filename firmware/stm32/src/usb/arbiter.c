/**
 * USB Arbiter
 *
 * The role of the USB arbiter is to handle USB OTG:
 * - host/device detection
 * - host mode: PSU management
 * - startup of appropriate USB drivers
 */

#include <ch.h>
#include <hal.h>

#include "usb/arbiter.h"
#include "usb/host.h"
#include "logger.h"

static void onOtgEvent(void *args);
static THD_WORKING_AREA(waUsbArbiterThread, 128);
static THD_FUNCTION(usbArbiterThread, arg);

static uint32_t inputLines[] = {
	LINE_USB_FS_ID, LINE_USB_FS_VBUS, LINE_USB_HS_ID, LINE_USB_HS_VBUS
};
typedef enum otg_status {
	OTG_STATUS_HOST = 0,  // Host mode, not powered yet
	OTG_STATUS_IDLE = 1,  // Idle, USB disconnected
	OTG_STATUS_PWR = 2,   // Host mode, device powered
	OTG_STATUS_DEV = 3    // Peripheral mode
} otg_status_t;
static const char *otgStatusDesc[] = {"host", "idle", "powered host", "device"};

static void handleTransition(otg_status_t from, otg_status_t to, bool isFs);

static event_source_t otgEvtSrc;

void usbArbiterInit(void) {
	// Setup input lines. Those allow to determine if we are device or host
	for (int i = 0; i < 4; i++) {
		palSetLineMode(inputLines[i], PAL_MODE_INPUT);
		palEnableLineEvent(inputLines[i], PAL_EVENT_MODE_BOTH_EDGES);
		palSetLineCallback(inputLines[i], onOtgEvent, NULL);
	}

	// Setup output lines. Those turn on or off the VBUS when we are host
	palSetLineMode(LINE_USB_FS_ON, PAL_MODE_OUTPUT_PUSHPULL);
	palClearLine(LINE_USB_FS_ON);
	palSetLineMode(LINE_USB_HS_ON, PAL_MODE_OUTPUT_PUSHPULL);
	palClearLine(LINE_USB_HS_ON);

	// Event source used for IRQ -> Arbiter communication
	chEvtObjectInit(&otgEvtSrc);

	// Start arbiter thread
	chThdCreateStatic(waUsbArbiterThread, sizeof(waUsbArbiterThread),
	                  NORMALPRIO + 10, usbArbiterThread, NULL);
}

// Called when any of the ID or VBUS pins transitions
static void onOtgEvent(void *args) {
	(void)args;

	eventflags_t flags = 0;
	for (int i = 0; i < 4; i++)
		flags |= palReadLine(inputLines[i]) << i;
	chEvtBroadcastFlagsI(&otgEvtSrc, flags);
}

// Handle IRQ events generated by the above function
static THD_FUNCTION(usbArbiterThread, arg) {
	(void)arg;
	chRegSetThreadName("USB Arbiter");

	// Register to OTG events
	event_listener_t otgEvtL;
	chEvtRegisterMask(&otgEvtSrc, &otgEvtL, EVENT_MASK(0));

	lognl("USB Arbiter started...");

	otg_status_t fs_cur = OTG_STATUS_IDLE, hs_cur = OTG_STATUS_IDLE;

	while (true) {
		eventmask_t evt = chEvtWaitAny(ALL_EVENTS);

		if (!(evt & EVENT_MASK(0)))
			continue;

		eventflags_t flags = chEvtGetAndClearFlags(&otgEvtL);
		otg_status_t fs = flags & 3, hs = (flags >> 2) & 3;

		if (fs_cur != fs) {
			lognl("OTG Event! USB FS transitioned from %s to %s",
				  otgStatusDesc[fs_cur], otgStatusDesc[fs]);
			handleTransition(fs_cur, fs, true);
			fs_cur = fs;
		}
		if (hs_cur != hs) {
			lognl("OTG Event! USB HS transitioned from %s to %s",
				  otgStatusDesc[hs_cur], otgStatusDesc[hs]);
			handleTransition(hs_cur, hs, false);
			hs_cur = hs;
		}
	}
}

// Handles a transition of a port from a state to another one
static void handleTransition(otg_status_t from, otg_status_t to, bool isFs) {
	const int busOnLine = isFs ? LINE_USB_FS_ON : LINE_USB_HS_ON;

	switch (from) {
	case OTG_STATUS_IDLE:
		switch (to) {
		case OTG_STATUS_HOST: // Idle -> host : power the device
			palSetLine(busOnLine);
			break;
		case OTG_STATUS_DEV:
			// TODO start device driver
			break;
		default:
			break;
		}
		break;
	case OTG_STATUS_HOST:
		switch (to) {
		case OTG_STATUS_PWR: // Host -> powered host : be a host
			usbHostStart(isFs);
			break;
		default:
			break;
		}
		break;
	case OTG_STATUS_PWR: // Power -> device is the only possible transition
		usbHostStop(isFs);
		// Power off the device. This will trigger the transition device -> idle
		palClearLine(busOnLine);
		break;
	case OTG_STATUS_DEV:
		// TODO stop device driver ONLY if loaded (in case of power -> device
		// transition)
		break;
	}
}
